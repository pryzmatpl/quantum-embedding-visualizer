<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Embedding Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .control-panel h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            padding-bottom: 10px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .input-group input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 14px;
        }
        
        .input-group input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .parameters-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            display: none;
        }
        
        .parameters-display.active {
            display: block;
        }
        
        .parameters-display h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .param-item {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        
        .param-item strong {
            display: inline-block;
            width: 80px;
        }
        
        .visualization-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 600px;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }
        
        .word-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .word-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .word-item:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .word-item.active {
            background: rgba(255,255,255,0.3);
            border: 2px solid #fff;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            background: rgba(0,255,0,0.2);
            display: none;
        }
        
        .status.error {
            background: rgba(255,0,0,0.2);
        }
        
        .status.active {
            display: block;
        }
        
        .wavefunction-view {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        
        .wavefunction-view h3 {
            margin-bottom: 10px;
        }
        
        #waveform-canvas {
            width: 100%;
            height: 150px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŒ Quantum Embedding Visualization</h1>
        
        <div class="main-content">
            <div class="control-panel">
                <h2>Controls</h2>
                
                <div class="input-group">
                    <label for="word-input">Word to Embed</label>
                    <input type="text" id="word-input" placeholder="Enter a word (e.g., 'quantum')">
                </div>
                
                <button onclick="loadEmbedding()">Load Embedding</button>
                <button onclick="addToSpace()">Add to 3D Space</button>
                <button onclick="visualizeSpace()">Visualize Full Space</button>
                <button onclick="clearSpace()">Clear Space</button>
                
                <div class="input-group" style="margin-top: 20px;">
                    <label for="word2-input">Second Word (for interaction)</label>
                    <input type="text" id="word2-input" placeholder="Enter second word">
                </div>
                
                <button onclick="computeInteraction()">Compute Quantum Interaction</button>
                
                <div class="status" id="status"></div>
                
                <div class="parameters-display" id="parameters">
                    <h3>Quantum Parameters</h3>
                    <div class="param-item">
                        <strong>Word:</strong> <span id="param-word">-</span>
                    </div>
                    <div class="param-item">
                        <strong>Î± (alpha):</strong> <span id="param-alpha">-</span>
                    </div>
                    <div class="param-item">
                        <strong>Î² (beta):</strong> <span id="param-beta">-</span>
                    </div>
                    <div class="param-item">
                        <strong>Î³ (gamma):</strong> <span id="param-gamma">-</span>
                    </div>
                </div>
                
                <div class="word-list" id="word-list">
                    <h3 style="margin-bottom: 10px;">Loaded Words</h3>
                    <div id="words-container"></div>
                </div>
            </div>
            
            <div class="visualization-container">
                <h2 style="margin-bottom: 15px;">3D Quantum Embedding Space</h2>
                <div id="canvas-container"></div>
                
                <div class="wavefunction-view" id="wavefunction-view" style="display: none;">
                    <h3>Wavefunction Visualization</h3>
                    <canvas id="waveform-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = 'http://localhost:8000/api';
        let scene, camera, renderer, controls;
        let loadedWords = new Map();
        let currentWord = null;
        
        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            try {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            } catch (e) {
                console.warn('OrbitControls not available, using basic controls');
                // Basic mouse controls
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                
                renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                renderer.domElement.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - previousMousePosition.x;
                        const deltaY = e.clientY - previousMousePosition.y;
                        const distance = camera.position.length();
                        const theta = Math.atan2(camera.position.x, camera.position.z) - deltaX * 0.01;
                        const phi = Math.acos(camera.position.y / distance) + deltaY * 0.01;
                        camera.position.x = distance * Math.sin(phi) * Math.sin(theta);
                        camera.position.y = distance * Math.cos(phi);
                        camera.position.z = distance * Math.sin(phi) * Math.cos(theta);
                        camera.lookAt(0, 0, 0);
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });
                
                renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
                renderer.domElement.addEventListener('wheel', (e) => {
                    const scale = e.deltaY > 0 ? 1.1 : 0.9;
                    camera.position.multiplyScalar(scale);
                });
                
                controls = { update: () => {} };
            }
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(30);
            scene.add(axesHelper);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(100, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // Add labels
            const labelX = createTextLabel('Î± (Alpha)', 30, 0, 0, 0xff0000);
            const labelY = createTextLabel('Î² (Beta)', 0, 30, 0, 0x00ff00);
            const labelZ = createTextLabel('Î³ (Gamma)', 0, 0, 30, 0x0000ff);
            scene.add(labelX, labelY, labelZ);
            
            animate();
        }
        
        function createTextLabel(text, x, y, z, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.font = 'Bold 24px Arial';
            context.fillText(text, 10, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(10, 2.5, 1);
            return sprite;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function showStatus(message, isError = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status active ${isError ? 'error' : ''}`;
            setTimeout(() => {
                status.className = 'status';
            }, 3000);
        }
        
        async function loadEmbedding() {
            const word = document.getElementById('word-input').value.trim().toLowerCase();
            if (!word) {
                showStatus('Please enter a word', true);
                return;
            }
            
            try {
                showStatus('Loading embedding...');
                const response = await fetch(`${API_BASE}/embedding`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word })
                });
                
                if (!response.ok) throw new Error('Failed to load embedding');
                
                const data = await response.json();
                currentWord = word;
                loadedWords.set(word, data);
                
                // Display parameters
                document.getElementById('param-word').textContent = data.word;
                document.getElementById('param-alpha').textContent = data.alpha.toFixed(4);
                document.getElementById('param-beta').textContent = data.beta.toFixed(4);
                document.getElementById('param-gamma').textContent = data.gamma.toFixed(4);
                document.getElementById('parameters').classList.add('active');
                
                // Update word list
                updateWordList();
                
                // Visualize wavefunction
                visualizeWavefunction(data.wavefunction);
                
                showStatus(`Loaded embedding for "${word}"`);
            } catch (error) {
                showStatus(`Error: ${error.message}`, true);
            }
        }
        
        function addToSpace() {
            if (!currentWord || !loadedWords.has(currentWord)) {
                showStatus('Please load an embedding first', true);
                return;
            }
            
            const data = loadedWords.get(currentWord);
            addPointToScene(data);
            showStatus(`Added "${currentWord}" to 3D space`);
        }
        
        function addPointToScene(embeddingData) {
            const { word, alpha, beta, gamma } = embeddingData;
            
            // Create sphere for the point
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6),
                emissive: new THREE.Color().setHSL(Math.random(), 0.5, 0.2)
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(alpha * 2, beta * 2, gamma * 2);
            sphere.userData = { word, alpha, beta, gamma };
            scene.add(sphere);
            
            // Add label
            const label = createWordLabel(word, alpha * 2, beta * 2, gamma * 2);
            scene.add(label);
            
            // Add light if needed
            if (scene.children.filter(c => c instanceof THREE.Light).length === 0) {
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(50, 50, 50);
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x404040));
            }
        }
        
        function createWordLabel(word, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 32;
            context.fillStyle = '#ffffff';
            context.font = '14px Arial';
            context.fillText(word, 5, 20);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x + 2, y + 2, z + 2);
            sprite.scale.set(5, 1.25, 1);
            return sprite;
        }
        
        async function visualizeSpace() {
            try {
                showStatus('Loading embedding space...');
                const words = Array.from(loadedWords.keys()).join(',');
                const response = await fetch(`${API_BASE}/space/3d?words=${words}`);
                
                if (!response.ok) throw new Error('Failed to load space');
                
                const data = await response.json();
                
                // Clear existing points (except axes and grid)
                scene.children = scene.children.filter(c => 
                    c instanceof THREE.AxesHelper || 
                    c instanceof THREE.GridHelper ||
                    c instanceof THREE.Sprite && (c.position.x === 30 || c.position.y === 30 || c.position.z === 30)
                );
                
                // Add all points
                data.points.forEach(point => {
                    const embeddingData = {
                        word: point.word,
                        alpha: point.alpha,
                        beta: point.beta,
                        gamma: point.gamma
                    };
                    addPointToScene(embeddingData);
                });
                
                showStatus(`Visualized ${data.count} embeddings in 3D space`);
            } catch (error) {
                showStatus(`Error: ${error.message}`, true);
            }
        }
        
        async function computeInteraction() {
            const word1 = document.getElementById('word-input').value.trim().toLowerCase();
            const word2 = document.getElementById('word2-input').value.trim().toLowerCase();
            
            if (!word1 || !word2) {
                showStatus('Please enter both words', true);
                return;
            }
            
            try {
                showStatus('Computing quantum interaction...');
                const response = await fetch(`${API_BASE}/interaction`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word1, word2 })
                });
                
                if (!response.ok) throw new Error('Failed to compute interaction');
                
                const data = await response.json();
                
                // Add both words to space
                if (!loadedWords.has(word1)) {
                    const emb1 = await fetch(`${API_BASE}/embedding`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ word: word1 })
                    }).then(r => r.json());
                    loadedWords.set(word1, emb1);
                }
                
                if (!loadedWords.has(word2)) {
                    const emb2 = await fetch(`${API_BASE}/embedding`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ word: word2 })
                    }).then(r => r.json());
                    loadedWords.set(word2, emb2);
                }
                
                addPointToScene(loadedWords.get(word1));
                addPointToScene(loadedWords.get(word2));
                
                // Visualize combined wavefunction
                visualizeWavefunction(data.combined_wavefunction);
                
                showStatus(`Similarity: ${(data.similarity * 100).toFixed(2)}%`);
                updateWordList();
            } catch (error) {
                showStatus(`Error: ${error.message}`, true);
            }
        }
        
        function clearSpace() {
            scene.children = scene.children.filter(c => 
                c instanceof THREE.AxesHelper || 
                c instanceof THREE.GridHelper ||
                (c instanceof THREE.Sprite && (c.position.x === 30 || c.position.y === 30 || c.position.z === 30))
            );
            loadedWords.clear();
            updateWordList();
            showStatus('Space cleared');
        }
        
        function visualizeWavefunction(wf) {
            const canvas = document.getElementById('waveform-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const x = wf.x;
            const real = wf.real;
            const scaleX = width / (x[x.length - 1] - x[0]);
            const scaleY = height / 4;
            const centerY = height / 2;
            
            for (let i = 0; i < x.length; i++) {
                const px = (x[i] - x[0]) * scaleX;
                const py = centerY - real[i] * scaleY;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            
            ctx.stroke();
            document.getElementById('wavefunction-view').style.display = 'block';
        }
        
        function updateWordList() {
            const container = document.getElementById('words-container');
            container.innerHTML = '';
            
            loadedWords.forEach((data, word) => {
                const item = document.createElement('div');
                item.className = 'word-item';
                if (word === currentWord) item.classList.add('active');
                item.textContent = word;
                item.onclick = () => {
                    currentWord = word;
                    const emb = loadedWords.get(word);
                    document.getElementById('param-word').textContent = emb.word;
                    document.getElementById('param-alpha').textContent = emb.alpha.toFixed(4);
                    document.getElementById('param-beta').textContent = emb.beta.toFixed(4);
                    document.getElementById('param-gamma').textContent = emb.gamma.toFixed(4);
                    visualizeWavefunction(emb.wavefunction);
                    updateWordList();
                };
                container.appendChild(item);
            });
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            initScene();
            
            // Handle Enter key
            document.getElementById('word-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') loadEmbedding();
            });
            
            document.getElementById('word2-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') computeInteraction();
            });
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>

